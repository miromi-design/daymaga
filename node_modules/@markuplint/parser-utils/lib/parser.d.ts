import type { Token, ChildToken, QuoteSet, ParseOptions, ParserOptions, Tokenized, ValueType } from './types.js';
import type { EndTagType, MLASTDocument, MLASTParentNode, MLParser, ParserAuthoredElementNameDistinguishing, MLASTElement, MLASTElementCloseTag, MLASTToken, MLASTNodeTreeItem, MLASTTag, MLASTText, MLASTAttr, MLASTChildNode, MLASTSpreadAttr, ElementType, Walker, MLASTHTMLAttr, MLASTPreprocessorSpecificBlockConditionalType } from '@markuplint/ml-ast';
import { AttrState } from './enums.js';
import { ParserError } from './parser-error.js';
export declare abstract class Parser<Node extends {} = {}, State extends unknown = null> implements MLParser {
    #private;
    state: State;
    constructor(options?: ParserOptions, defaultState?: State);
    get authoredElementName(): ParserAuthoredElementNameDistinguishing | undefined;
    /**
     * Detect value as a true if its attribute is booleanish value and omitted.
     *
     * Ex:
     * ```jsx
     * <Component aria-hidden />
     * ```
     *
     * In the above, the `aria-hidden` is `true`.
     */
    get booleanish(): boolean;
    /**
     * The end tag omittable type.
     *
     * - `"xml"`: Must need an end tag or must self-close
     * - `"omittable"`: May omit
     * - `"never"`: Never need
     */
    get endTag(): EndTagType;
    get rawCode(): string;
    get tagNameCaseSensitive(): boolean;
    tokenize(options?: ParseOptions): Tokenized<Node, State>;
    beforeParse(rawCode: string, options?: ParseOptions): string;
    parse(rawCode: string, options?: ParseOptions): MLASTDocument;
    afterParse(nodeList: readonly MLASTNodeTreeItem[], options?: ParseOptions): readonly MLASTNodeTreeItem[];
    parseError(error: any): ParserError;
    traverse(originNodes: readonly Node[], parentNode: (MLASTParentNode | null) | undefined, depth: number): {
        childNodes: readonly MLASTChildNode[];
        siblings: readonly MLASTNodeTreeItem[];
    };
    afterTraverse(nodeTree: readonly MLASTNodeTreeItem[]): readonly MLASTNodeTreeItem[];
    nodeize(originNode: Node, parentNode: MLASTParentNode | null, depth: number): readonly MLASTNodeTreeItem[];
    afterNodeize(siblings: readonly MLASTNodeTreeItem[], parentNode: MLASTParentNode | null, depth: number): {
        siblings: MLASTChildNode[];
        ancestors: MLASTNodeTreeItem[];
    };
    flattenNodes(nodeTree: readonly MLASTNodeTreeItem[]): readonly MLASTNodeTreeItem[];
    afterFlattenNodes(nodeList: readonly MLASTNodeTreeItem[], options?: {
        readonly exposeInvalidNode?: boolean;
        readonly exposeWhiteSpace?: boolean;
        readonly concatText?: boolean;
    }): readonly MLASTNodeTreeItem[];
    visitDoctype(token: ChildToken & {
        readonly name: string;
        readonly publicId: string;
        readonly systemId: string;
    }): readonly MLASTNodeTreeItem[];
    visitComment(token: ChildToken, options?: {
        readonly isBogus?: boolean;
    }): readonly MLASTNodeTreeItem[];
    visitText(token: ChildToken, options?: {
        readonly researchTags?: boolean;
        readonly invalidTagAsText?: boolean;
    }): readonly MLASTNodeTreeItem[];
    visitElement(token: ChildToken & {
        readonly nodeName: string;
        readonly namespace: string;
    }, childNodes?: readonly Node[], options?: {
        readonly createEndTagToken?: (startTag: MLASTElement) => ChildToken | null;
        readonly namelessFragment?: boolean;
        readonly overwriteProps?: Partial<MLASTElement>;
    }): readonly MLASTNodeTreeItem[];
    visitPsBlock(token: ChildToken & {
        readonly nodeName: string;
        readonly isFragment: boolean;
    }, childNodes?: readonly Node[], conditionalType?: MLASTPreprocessorSpecificBlockConditionalType, originBlockNode?: Node): readonly MLASTNodeTreeItem[];
    visitChildren(children: readonly Node[], parentNode: MLASTParentNode | null): readonly MLASTNodeTreeItem[];
    visitSpreadAttr(token: Token): MLASTSpreadAttr | null;
    visitAttr(token: Token, options?: {
        readonly quoteSet?: readonly QuoteSet[];
        readonly noQuoteValueType?: ValueType;
        readonly endOfUnquotedValueChars?: readonly string[];
        readonly startState?: AttrState;
    }): MLASTAttr & {
        __rightText?: string;
    };
    parseCodeFragment(token: ChildToken, options?: {
        readonly namelessFragment?: boolean;
    }): (MLASTTag | MLASTText)[];
    updateLocation(node: MLASTNodeTreeItem, props: Partial<Pick<MLASTNodeTreeItem, 'startOffset' | 'startLine' | 'startCol' | 'depth'>>): void;
    /**
     * Set new raw code to target node.
     *
     * Replace the raw code and update the start/end offset/line/column.
     *
     * @param node target node
     * @param raw new raw code
     */
    updateRaw(node: MLASTToken, raw: string): void;
    updateElement(el: MLASTElement, props: Partial<Pick<MLASTElement, 'nodeName' | 'elementType'>>): void;
    updateElement(el: MLASTElementCloseTag, props: Partial<Pick<MLASTElementCloseTag, 'nodeName'>>): void;
    updateAttr(attr: MLASTHTMLAttr, props: Partial<Pick<MLASTHTMLAttr, 'isDynamicValue' | 'isDirective' | 'potentialName' | 'potentialValue' | 'valueType' | 'candidate' | 'isDuplicatable'>>): void;
    detectElementType(nodeName: string, defaultPattern?: ParserAuthoredElementNameDistinguishing): ElementType;
    createToken(token: Token): MLASTToken;
    createToken(token: string, startOffset: number, startLine: number, startCol: number): MLASTToken;
    sliceFragment(start: number, end?: number): Token;
    getOffsetsFromCode(startLine: number, startCol: number, endLine: number, endCol: number): {
        offset: number;
        endOffset: number;
    };
    walk<Node extends MLASTNodeTreeItem>(nodeList: readonly Node[], walker: Walker<Node>, depth?: number): void;
    appendChild(parentNode: MLASTParentNode | null, ...childNodes: readonly MLASTChildNode[]): void;
    replaceChild(parentNode: MLASTParentNode, oldChildNode: MLASTChildNode, ...replacementChildNodes: readonly MLASTChildNode[]): void;
}
