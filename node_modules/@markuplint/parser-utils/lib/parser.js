var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Parser_instances, _Parser_booleanish, _Parser_defaultState, _Parser_endTagType, _Parser_ignoreTags, _Parser_maskChar, _Parser_tagNameCaseSensitive, _Parser_selfCloseType, _Parser_spaceChars, _Parser_rawTextElements, _Parser_authoredElementName, _Parser_originalRawCode, _Parser_rawCode, _Parser_defaultDepth, _Parser_walkMethodSequentailPrevNode, _Parser_arrayize, _Parser_concatText, _Parser_concatTextNodes, _Parser_convertIntoInvalidNode, _Parser_createOffsetSpaces, _Parser_createRemnantNode, _Parser_exposeRemnantNodes, _Parser_getEndLocation, _Parser_orphanEndTagToBogusMark, _Parser_pairing, _Parser_parseEndTag, _Parser_parseStartTag, _Parser_parseTag, _Parser_removeChild, _Parser_removeDeprecatedNode, _Parser_removeOffsetSpaces, _Parser_reset, _Parser_setRawCode, _Parser_siblingsCorrection, _Parser_trimText;
import { isVoidElement as detectVoidElement } from '@markuplint/ml-spec';
import { v4 as uuid } from 'uuid';
import { attrTokenizer } from './attr-tokenizer.js';
import { defaultSpaces } from './const.js';
import { domLog } from './debug.js';
import { detectElementType } from './detect-element-type.js';
import { AttrState, TagState } from './enums.js';
import { getEndCol, getEndLine, getPosition } from './get-location.js';
import { ignoreBlock, restoreNode } from './ignore-block.js';
import { ignoreFrontMatter } from './ignore-front-matter.js';
import { ParserError } from './parser-error.js';
import { sortNodes } from './sort-nodes.js';
export class Parser {
    constructor(options, defaultState) {
        _Parser_instances.add(this);
        _Parser_booleanish.set(this, false);
        _Parser_defaultState.set(this, void 0);
        _Parser_endTagType.set(this, 'omittable');
        _Parser_ignoreTags.set(this, []);
        _Parser_maskChar.set(this, void 0);
        _Parser_tagNameCaseSensitive.set(this, false);
        _Parser_selfCloseType.set(this, 'html');
        _Parser_spaceChars.set(this, defaultSpaces);
        _Parser_rawTextElements.set(this, ['style', 'script']);
        _Parser_authoredElementName.set(this, void 0);
        _Parser_originalRawCode.set(this, '');
        _Parser_rawCode.set(this, '');
        _Parser_defaultDepth.set(this, 0);
        _Parser_walkMethodSequentailPrevNode.set(this, null);
        __classPrivateFieldSet(this, _Parser_booleanish, options?.booleanish ?? __classPrivateFieldGet(this, _Parser_booleanish, "f"), "f");
        __classPrivateFieldSet(this, _Parser_endTagType, options?.endTagType ?? __classPrivateFieldGet(this, _Parser_endTagType, "f"), "f");
        __classPrivateFieldSet(this, _Parser_ignoreTags, options?.ignoreTags ?? __classPrivateFieldGet(this, _Parser_ignoreTags, "f"), "f");
        __classPrivateFieldSet(this, _Parser_maskChar, options?.maskChar ?? __classPrivateFieldGet(this, _Parser_maskChar, "f"), "f");
        __classPrivateFieldSet(this, _Parser_tagNameCaseSensitive, options?.tagNameCaseSensitive ?? __classPrivateFieldGet(this, _Parser_tagNameCaseSensitive, "f"), "f");
        __classPrivateFieldSet(this, _Parser_selfCloseType, options?.selfCloseType ?? __classPrivateFieldGet(this, _Parser_selfCloseType, "f"), "f");
        __classPrivateFieldSet(this, _Parser_spaceChars, options?.spaceChars ?? __classPrivateFieldGet(this, _Parser_spaceChars, "f"), "f");
        __classPrivateFieldSet(this, _Parser_rawTextElements, options?.rawTextElements ?? __classPrivateFieldGet(this, _Parser_rawTextElements, "f"), "f");
        __classPrivateFieldSet(this, _Parser_defaultState, defaultState ?? null, "f");
        this.state = structuredClone(__classPrivateFieldGet(this, _Parser_defaultState, "f"));
    }
    get authoredElementName() {
        return __classPrivateFieldGet(this, _Parser_authoredElementName, "f");
    }
    /**
     * Detect value as a true if its attribute is booleanish value and omitted.
     *
     * Ex:
     * ```jsx
     * <Component aria-hidden />
     * ```
     *
     * In the above, the `aria-hidden` is `true`.
     */
    get booleanish() {
        return __classPrivateFieldGet(this, _Parser_booleanish, "f");
    }
    /**
     * The end tag omittable type.
     *
     * - `"xml"`: Must need an end tag or must self-close
     * - `"omittable"`: May omit
     * - `"never"`: Never need
     */
    get endTag() {
        return __classPrivateFieldGet(this, _Parser_endTagType, "f");
    }
    get rawCode() {
        return __classPrivateFieldGet(this, _Parser_rawCode, "f");
    }
    get tagNameCaseSensitive() {
        return __classPrivateFieldGet(this, _Parser_tagNameCaseSensitive, "f");
    }
    tokenize(options) {
        return {
            ast: [],
            isFragment: false,
        };
    }
    beforeParse(rawCode, options) {
        const spaces = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_createOffsetSpaces).call(this, options);
        return spaces + rawCode;
    }
    parse(rawCode, options) {
        try {
            // Initialize raw code
            __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_setRawCode).call(this, rawCode, rawCode);
            // Override raw code
            __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_setRawCode).call(this, this.beforeParse(this.rawCode, options));
            __classPrivateFieldSet(this, _Parser_authoredElementName, options?.authoredElementName, "f");
            let frontMatter = null;
            if (options?.ignoreFrontMatter) {
                const fm = ignoreFrontMatter(this.rawCode);
                __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_setRawCode).call(this, fm.code);
                frontMatter = fm.frontMatter;
            }
            const blocks = ignoreBlock(this.rawCode, __classPrivateFieldGet(this, _Parser_ignoreTags, "f"), __classPrivateFieldGet(this, _Parser_maskChar, "f"));
            __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_setRawCode).call(this, blocks.replaced);
            const tokenized = this.tokenize(options);
            const ast = tokenized.ast;
            const isFragment = tokenized.isFragment;
            __classPrivateFieldSet(this, _Parser_defaultDepth, options?.depth ?? __classPrivateFieldGet(this, _Parser_defaultDepth, "f"), "f");
            const traversed = this.traverse(ast, null, __classPrivateFieldGet(this, _Parser_defaultDepth, "f"));
            const nodeTree = this.afterTraverse([...traversed.childNodes, ...traversed.siblings]);
            let nodeList = this.flattenNodes(nodeTree);
            nodeList = this.afterFlattenNodes(nodeList);
            nodeList = restoreNode(this, nodeList, blocks, false);
            nodeList = this.afterParse(nodeList, options);
            if (frontMatter) {
                const newNodeList = [...nodeList];
                let firstText = '';
                const firstTextNode = newNodeList.shift();
                if (firstTextNode && firstTextNode.type === 'text') {
                    firstText = firstTextNode.raw;
                }
                else if (firstTextNode) {
                    newNodeList.unshift(firstTextNode);
                }
                const raw = frontMatter + firstText.slice(frontMatter.length);
                const token = this.sliceFragment(0, raw.length);
                const fmNode = this.visitPsBlock({
                    ...token,
                    depth: 0,
                    parentNode: null,
                    raw,
                    nodeName: 'front-matter',
                    isFragment: false,
                })[0];
                if (!fmNode) {
                    throw new ParserError('Unexpected front matter', firstTextNode ?? token);
                }
                nodeList = [fmNode, ...newNodeList];
            }
            domLog(nodeList);
            __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_reset).call(this);
            return {
                raw: rawCode,
                nodeList,
                isFragment,
            };
        }
        catch (error) {
            throw this.parseError(error);
        }
    }
    afterParse(nodeList, options) {
        return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_removeOffsetSpaces).call(this, nodeList, options);
    }
    parseError(error) {
        return new ParserError(error, {
            line: error.line ?? error.lineNumber ?? 0,
            col: error.col ?? error.column ?? 0,
            raw: error.raw ?? this.rawCode,
            stack: error.stack,
        });
    }
    traverse(originNodes, parentNode = null, depth) {
        if (originNodes.length === 0) {
            return {
                childNodes: [],
                siblings: [],
            };
        }
        const childNodes = [];
        const siblings = [];
        for (const originNode of originNodes) {
            const nodes = this.nodeize(originNode, parentNode, depth);
            const after = this.afterNodeize(nodes, parentNode, depth);
            childNodes.push(...after.siblings);
            siblings.push(...after.ancestors);
        }
        return {
            childNodes,
            siblings,
        };
    }
    afterTraverse(nodeTree) {
        return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_siblingsCorrection).call(this, nodeTree);
    }
    nodeize(originNode, parentNode, depth) {
        return [];
    }
    afterNodeize(siblings, parentNode, depth) {
        const newSiblings = [];
        const ancestors = [];
        for (const sibling of siblings) {
            if (sibling.type === 'doctype') {
                if (sibling.depth === 0) {
                    ancestors.push(sibling);
                    continue;
                }
                throw new ParserError('Unexpected doctype', sibling);
            }
            if (sibling.depth === depth) {
                newSiblings.push(sibling);
                continue;
            }
            if (sibling.depth < depth) {
                ancestors.push(sibling);
                continue;
            }
        }
        return {
            siblings: newSiblings,
            ancestors,
        };
    }
    flattenNodes(nodeTree) {
        return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_arrayize).call(this, nodeTree);
    }
    afterFlattenNodes(nodeList, options) {
        const exposeInvalidNode = options?.exposeInvalidNode ?? true;
        const exposeWhiteSpace = options?.exposeWhiteSpace ?? true;
        const concatText = options?.concatText ?? true;
        nodeList = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_exposeRemnantNodes).call(this, nodeList, exposeInvalidNode, exposeWhiteSpace);
        nodeList = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_orphanEndTagToBogusMark).call(this, nodeList);
        if (concatText) {
            nodeList = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_concatText).call(this, nodeList);
        }
        nodeList = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_trimText).call(this, nodeList);
        return nodeList;
    }
    visitDoctype(token) {
        const node = {
            ...token,
            ...this.createToken(token),
            type: 'doctype',
            nodeName: '#doctype',
        };
        return [node];
    }
    visitComment(token, options) {
        const isBogus = options?.isBogus ?? !token.raw.startsWith('<!--');
        const node = {
            ...token,
            ...this.createToken(token),
            type: 'comment',
            nodeName: '#comment',
            isBogus,
        };
        return [node];
    }
    visitText(token, options) {
        const node = {
            ...token,
            ...this.createToken(token),
            type: 'text',
            nodeName: '#text',
        };
        if (options?.researchTags) {
            const nodes = this.parseCodeFragment(token);
            const includedStartTags = nodes.some(node => node.type === 'starttag');
            // Handle invalid tags as text nodes
            if (options.invalidTagAsText && includedStartTags) {
                return [node];
            }
            return nodes;
        }
        return [node];
    }
    visitElement(token, childNodes = [], options) {
        const createEndTagToken = options?.createEndTagToken;
        const namelessFragment = options?.namelessFragment ?? false;
        const overwriteProps = options?.overwriteProps;
        // Handle omitted empty tag as ghost element node
        if (token.raw === '') {
            const startTag = {
                ...token,
                ...this.createToken(token),
                type: 'starttag',
                elementType: 'html',
                attributes: [],
                childNodes: [],
                parentNode: token.parentNode,
                pairNode: null,
                tagCloseChar: '',
                tagOpenChar: '',
                isGhost: true,
                isFragment: false,
                ...overwriteProps,
            };
            const siblings = this.visitChildren(childNodes, startTag);
            return [startTag, ...siblings];
        }
        const startTag = {
            ...__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseStartTag).call(this, token, {
                namespace: token.namespace,
                ...overwriteProps,
            }, namelessFragment),
        };
        const siblings = this.visitChildren(childNodes, startTag);
        if (createEndTagToken) {
            const endTagToken = createEndTagToken(startTag);
            if (endTagToken) {
                const endTag = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseEndTag).call(this, endTagToken, namelessFragment);
                __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_pairing).call(this, startTag, endTag);
                return [startTag, endTag, ...siblings];
            }
        }
        return [startTag, ...siblings];
    }
    visitPsBlock(token, childNodes = [], conditionalType = null, originBlockNode) {
        const block = {
            ...token,
            ...this.createToken(token),
            type: 'psblock',
            conditionalType,
            nodeName: `#ps:${token.nodeName}`,
            childNodes: [],
            isBogus: false,
        };
        const siblings = this.visitChildren(childNodes, block);
        return [block, ...siblings];
    }
    visitChildren(children, parentNode) {
        if (children.length === 0) {
            return [];
        }
        if (parentNode && __classPrivateFieldGet(this, _Parser_rawTextElements, "f").includes(parentNode.nodeName.toLowerCase())) {
            return [];
        }
        const traversed = this.traverse(children, parentNode, parentNode ? parentNode.depth + 1 : 0);
        this.appendChild(parentNode, ...traversed.childNodes);
        return traversed.siblings;
    }
    visitSpreadAttr(token) {
        const raw = token.raw.trim();
        if (raw === '') {
            return null;
        }
        // eslint-disable-next-line regexp/strict
        if (!/^{\s*\.{3}[^.]/.test(raw)) {
            return null;
        }
        if (!raw.endsWith('}')) {
            return null;
        }
        const node = this.createToken(raw, token.startOffset, token.startLine, token.startCol);
        return {
            ...node,
            ...__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_getEndLocation).call(this, node),
            type: 'spread',
            nodeName: '#spread',
        };
    }
    visitAttr(token, options) {
        const raw = token.raw;
        const quoteSet = options?.quoteSet;
        const startState = options?.startState ?? AttrState.BeforeName;
        const noQuoteValueType = options?.noQuoteValueType;
        const endOfUnquotedValueChars = options?.endOfUnquotedValueChars;
        let startOffset = token.startOffset;
        let startLine = token.startLine;
        let startCol = token.startCol;
        let tokens;
        try {
            tokens = attrTokenizer(raw, quoteSet, startState, noQuoteValueType, endOfUnquotedValueChars);
        }
        catch (error) {
            if (error instanceof SyntaxError) {
                throw new ParserError(error.message, token);
            }
            throw error;
        }
        const spacesBeforeName = this.createToken(tokens.spacesBeforeAttrName, startOffset, startLine, startCol);
        startLine = spacesBeforeName.endLine;
        startCol = spacesBeforeName.endCol;
        startOffset = spacesBeforeName.endOffset;
        const name = this.createToken(tokens.attrName, startOffset, startLine, startCol);
        startLine = name.endLine;
        startCol = name.endCol;
        startOffset = name.endOffset;
        const spacesBeforeEqual = this.createToken(tokens.spacesBeforeEqual, startOffset, startLine, startCol);
        startLine = spacesBeforeEqual.endLine;
        startCol = spacesBeforeEqual.endCol;
        startOffset = spacesBeforeEqual.endOffset;
        const equal = this.createToken(tokens.equal, startOffset, startLine, startCol);
        startLine = equal.endLine;
        startCol = equal.endCol;
        startOffset = equal.endOffset;
        const spacesAfterEqual = this.createToken(tokens.spacesAfterEqual, startOffset, startLine, startCol);
        startLine = spacesAfterEqual.endLine;
        startCol = spacesAfterEqual.endCol;
        startOffset = spacesAfterEqual.endOffset;
        const startQuote = this.createToken(tokens.quoteStart, startOffset, startLine, startCol);
        startLine = startQuote.endLine;
        startCol = startQuote.endCol;
        startOffset = startQuote.endOffset;
        const value = this.createToken(tokens.attrValue, startOffset, startLine, startCol);
        startLine = value.endLine;
        startCol = value.endCol;
        startOffset = value.endOffset;
        const endQuote = this.createToken(tokens.quoteEnd, startOffset, startLine, startCol);
        const attrToken = this.createToken(tokens.attrName +
            tokens.spacesBeforeEqual +
            tokens.equal +
            tokens.spacesAfterEqual +
            tokens.quoteStart +
            tokens.attrValue +
            tokens.quoteEnd, name.startOffset, name.startLine, name.startCol);
        const htmlAttr = {
            ...attrToken,
            type: 'attr',
            nodeName: name.raw,
            spacesBeforeName,
            name,
            spacesBeforeEqual,
            equal,
            spacesAfterEqual,
            startQuote,
            value,
            endQuote,
            isDuplicatable: false,
        };
        const spread = this.visitSpreadAttr(attrToken);
        if (tokens.leftover) {
            return {
                ...(spread ?? htmlAttr),
                __rightText: tokens.leftover,
            };
        }
        return spread ?? htmlAttr;
    }
    parseCodeFragment(token, options) {
        const nodes = [];
        let raw = token.raw;
        let startOffset = token.startOffset;
        let startLine = token.startLine;
        let startCol = token.startCol;
        let depth = token.depth;
        const depthStack = new Map();
        while (raw) {
            const parsed = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseTag).call(this, {
                raw,
                startOffset,
                startLine,
                startCol,
                depth,
                parentNode: null,
            }, true, true, options?.namelessFragment ?? false);
            if (parsed.__left) {
                const token = this.createToken(parsed.__left, startOffset, startLine, startCol);
                const textNode = {
                    ...token,
                    type: 'text',
                    depth,
                    nodeName: '#text',
                    parentNode: null,
                };
                nodes.push(textNode);
            }
            raw = parsed.__right ?? '';
            if (!parsed.token) {
                continue;
            }
            const tag = parsed.token;
            startLine = tag.endLine;
            startCol = tag.endCol;
            startOffset = tag.endOffset;
            let isSelfClose = tag.type === 'starttag' && tag.selfClosingSolidus?.raw === '/';
            const isVoidElement = detectVoidElement({ localName: tag.nodeName.toLowerCase() });
            switch (__classPrivateFieldGet(this, _Parser_selfCloseType, "f")) {
                case 'html': {
                    isSelfClose = isVoidElement;
                    break;
                }
                case 'html+xml': {
                    isSelfClose = isSelfClose || isVoidElement;
                    break;
                }
                case 'xml': {
                    // eslint-disable-next-line no-self-assign
                    isSelfClose = isSelfClose;
                    break;
                }
            }
            if (tag.type === 'starttag' && !isSelfClose) {
                depthStack.set(tag.nodeName, depth);
            }
            if (tag.raw) {
                if (tag.type === 'endtag') {
                    if (depthStack.has(tag.nodeName)) {
                        depth = depthStack.get(tag.nodeName);
                        depthStack.delete(tag.nodeName);
                    }
                    else {
                        depth = Math.max(depth - 1, __classPrivateFieldGet(this, _Parser_defaultDepth, "f"));
                    }
                    this.updateLocation(tag, {
                        depth,
                    });
                }
                else if (!isSelfClose) {
                    depth += 1;
                }
                /**
                 * The DOM parser sometimes includes HTML closing tags as a text node child of the body element.
                 * In that case, it is ignored.
                 */
                if (token.parentNode?.nodeName === 'body' && tag.nodeName === 'html' && tag.type === 'endtag') {
                    continue;
                }
                nodes.push(tag);
            }
        }
        return nodes;
    }
    updateLocation(node, props) {
        Object.assign(node, {
            startOffset: props.startOffset ?? node.startOffset,
            startLine: props.startLine ?? node.startLine,
            startCol: props.startCol ?? node.startCol,
            endOffset: props.startOffset == null ? node.endOffset : props.startOffset + node.raw.length,
            endLine: props.startLine == null ? node.endLine : getEndLine(node.raw, props.startLine),
            endCol: props.startCol == null ? node.endCol : getEndCol(node.raw, props.startCol),
            depth: props.depth ?? node.depth,
        });
    }
    /**
     * Set new raw code to target node.
     *
     * Replace the raw code and update the start/end offset/line/column.
     *
     * @param node target node
     * @param raw new raw code
     */
    updateRaw(node, raw) {
        const startOffset = node.startOffset;
        const startLine = node.startLine;
        const startCol = node.startCol;
        const endOffset = startOffset + raw.length;
        const endLine = getEndLine(raw, startLine);
        const endCol = getEndCol(raw, startCol);
        Object.assign(node, {
            raw,
            startOffset,
            endOffset,
            startLine,
            endLine,
            startCol,
            endCol,
        });
    }
    updateElement(el, props) {
        Object.assign(el, props);
    }
    updateAttr(attr, props) {
        Object.assign(attr, props);
    }
    detectElementType(nodeName, defaultPattern) {
        return detectElementType(nodeName, __classPrivateFieldGet(this, _Parser_authoredElementName, "f"), defaultPattern);
    }
    createToken(token, startOffset, startLine, startCol) {
        const props = typeof token === 'string'
            ? {
                raw: token,
                startOffset: startOffset ?? 0,
                startLine: startLine ?? 1,
                startCol: startCol ?? 1,
            }
            : token;
        return {
            uuid: uuid().slice(0, 8),
            ...props,
            ...__classPrivateFieldGet(this, _Parser_instances, "m", _Parser_getEndLocation).call(this, props),
        };
    }
    sliceFragment(start, end) {
        const raw = this.rawCode.slice(start, end);
        const { line, column } = getPosition(this.rawCode, start);
        return {
            raw,
            startOffset: start,
            startLine: line,
            startCol: column,
        };
    }
    getOffsetsFromCode(startLine, startCol, endLine, endCol) {
        const lines = __classPrivateFieldGet(this, _Parser_rawCode, "f").split('\n');
        let offset = 0;
        let endOffset = 0;
        for (let i = 0; i < startLine - 1; i++) {
            const line = lines[i];
            if (line == null) {
                continue;
            }
            offset += line.length + 1;
        }
        offset += startCol - 1;
        for (let i = 0; i < endLine - 1; i++) {
            const line = lines[i];
            if (line == null) {
                continue;
            }
            endOffset += line.length + 1;
        }
        endOffset += endCol - 1;
        return { offset, endOffset };
    }
    walk(nodeList, walker, depth = 0) {
        for (const node of nodeList) {
            walker(node, __classPrivateFieldGet(this, _Parser_walkMethodSequentailPrevNode, "f"), depth);
            __classPrivateFieldSet(this, _Parser_walkMethodSequentailPrevNode, node, "f");
            if ('childNodes' in node && node.childNodes.length > 0) {
                this.walk(node.childNodes, walker, depth + 1);
            }
        }
        if (depth === 0) {
            __classPrivateFieldSet(this, _Parser_walkMethodSequentailPrevNode, null, "f");
        }
    }
    appendChild(parentNode, ...childNodes) {
        if (!parentNode || childNodes.length === 0) {
            return;
        }
        const newChildNodes = [...parentNode.childNodes];
        for (const appendingChild of childNodes) {
            const currentIndex = parentNode.childNodes.findIndex(n => n.uuid === appendingChild.uuid);
            Object.assign(appendingChild, { parentNode });
            if (currentIndex === -1) {
                newChildNodes.push(appendingChild);
                continue;
            }
            newChildNodes.splice(currentIndex, 1, appendingChild);
        }
        Object.assign(parentNode, {
            childNodes: __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_siblingsCorrection).call(this, newChildNodes),
        });
    }
    replaceChild(parentNode, oldChildNode, ...replacementChildNodes) {
        const index = parentNode.childNodes.findIndex(childNode => childNode.uuid === oldChildNode.uuid);
        if (index === -1) {
            return;
        }
        if (Array.prototype.toSpliced == null) {
            const newChildNodes = [...parentNode.childNodes];
            // TODO: Use splice instead of toSpliced until we end support for Node 18
            newChildNodes.splice(index, 1, ...replacementChildNodes);
            Object.assign(parentNode, { childNodes: newChildNodes });
            return;
        }
        const newChildNodes = parentNode.childNodes.toSpliced(index, 1, ...replacementChildNodes);
        Object.assign(parentNode, { childNodes: newChildNodes });
    }
}
_Parser_booleanish = new WeakMap(), _Parser_defaultState = new WeakMap(), _Parser_endTagType = new WeakMap(), _Parser_ignoreTags = new WeakMap(), _Parser_maskChar = new WeakMap(), _Parser_tagNameCaseSensitive = new WeakMap(), _Parser_selfCloseType = new WeakMap(), _Parser_spaceChars = new WeakMap(), _Parser_rawTextElements = new WeakMap(), _Parser_authoredElementName = new WeakMap(), _Parser_originalRawCode = new WeakMap(), _Parser_rawCode = new WeakMap(), _Parser_defaultDepth = new WeakMap(), _Parser_walkMethodSequentailPrevNode = new WeakMap(), _Parser_instances = new WeakSet(), _Parser_arrayize = function _Parser_arrayize(nodeTree) {
    let nodeList = [];
    this.walk(nodeTree, node => {
        nodeList.push(node);
    });
    nodeList = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_removeDeprecatedNode).call(this, nodeList);
    return nodeList;
}, _Parser_concatText = function _Parser_concatText(nodeList) {
    const newNodeList = [];
    for (const node of nodeList) {
        const prevNode = newNodeList.at(-1) ?? null;
        if (prevNode?.type === 'text' &&
            prevNode?.nodeName === '#text' &&
            node.type === 'text' &&
            node.nodeName === '#text' &&
            prevNode?.endOffset === node.startOffset) {
            const newNode = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_concatTextNodes).call(this, prevNode, node);
            newNodeList.pop();
            newNodeList.push(newNode);
            continue;
        }
        newNodeList.push(node);
    }
    return newNodeList;
}, _Parser_concatTextNodes = function _Parser_concatTextNodes(...nodes) {
    if (nodes.length === 0) {
        throw new Error('Empty node list');
    }
    const firstNode = nodes.at(0);
    const lastNode = nodes.at(-1);
    if (firstNode.uuid === lastNode.uuid) {
        return firstNode;
    }
    const textNode = {
        ...firstNode,
        uuid: uuid().slice(0, 8),
        raw: nodes.map(n => n.raw).join(''),
        endOffset: lastNode.endOffset,
        endLine: lastNode.endLine,
        endCol: lastNode.endCol,
    };
    for (const node of nodes) {
        __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_removeChild).call(this, node.parentNode, node);
    }
    this.appendChild(textNode.parentNode, textNode);
    return textNode;
}, _Parser_convertIntoInvalidNode = function _Parser_convertIntoInvalidNode(node) {
    if (node.type === 'invalid') {
        return node;
    }
    return {
        ...node,
        type: 'invalid',
        nodeName: '#invalid',
        isBogus: true,
        kind: node.type,
    };
}, _Parser_createOffsetSpaces = function _Parser_createOffsetSpaces(options) {
    const offsetOffset = Math.max(options?.offsetOffset ?? 0, 0);
    const offsetLine = Math.max((options?.offsetLine ?? 0) - 1, 0);
    const offsetColumn = Math.max((options?.offsetColumn ?? 0) - 1, 0);
    const offsetSpaces = ' '.repeat(offsetOffset - offsetLine - offsetColumn);
    const offsetLines = '\n'.repeat(offsetLine);
    const offsetColumns = ' '.repeat(offsetColumn);
    return offsetSpaces + offsetLines + offsetColumns;
}, _Parser_createRemnantNode = function _Parser_createRemnantNode(start, end, depth, parentNode, exposeInvalidNode, exposeWhitespace) {
    const codeFragment = this.sliceFragment(start, end);
    if (codeFragment.raw) {
        const remnantNodes = this.visitText({
            ...codeFragment,
            depth: depth,
            parentNode: parentNode,
        }, { researchTags: true }).filter((node) => 'parentNode' in node);
        if (remnantNodes.length > 1) {
            this.appendChild(parentNode, ...remnantNodes);
            return remnantNodes;
        }
        const remnantNode = remnantNodes[0];
        if (!remnantNode) {
            return null;
        }
        if (exposeInvalidNode && remnantNode.raw.trim() !== '') {
            const invalidNode = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_convertIntoInvalidNode).call(this, remnantNode);
            this.appendChild(parentNode, invalidNode);
            return [remnantNode];
        }
        if (exposeWhitespace && remnantNode.type === 'text' && remnantNode.raw.trim() === '') {
            this.appendChild(parentNode, remnantNode);
            return [remnantNode];
        }
    }
    return null;
}, _Parser_exposeRemnantNodes = function _Parser_exposeRemnantNodes(nodeList, invalidNode, whitespace) {
    if (!invalidNode && !whitespace) {
        return nodeList;
    }
    const newNodeList = [];
    for (const [i, node] of nodeList.entries()) {
        const sequentailPrevNode = nodeList[i - 1] ?? null;
        if (!__classPrivateFieldGet(this, _Parser_rawTextElements, "f").includes(node.nodeName.toLowerCase())) {
            const endOffset = sequentailPrevNode?.endOffset ?? 0;
            const remnantNodes = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_createRemnantNode).call(this, endOffset, node.startOffset, node.depth, node.parentNode, invalidNode, whitespace);
            if (remnantNodes) {
                newNodeList.push(...remnantNodes);
            }
        }
        newNodeList.push(node);
    }
    const lastNode = newNodeList.at(-1);
    if (!lastNode) {
        return newNodeList;
    }
    const remnantNodes = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_createRemnantNode).call(this, lastNode.endOffset, undefined, lastNode.depth, lastNode.parentNode, invalidNode, whitespace);
    if (!remnantNodes) {
        return newNodeList;
    }
    newNodeList.push(...remnantNodes);
    return newNodeList;
}, _Parser_getEndLocation = function _Parser_getEndLocation(token) {
    const endOffset = token.startOffset + token.raw.length;
    return {
        endOffset,
        endLine: getEndLine(token.raw, token.startLine),
        endCol: getEndCol(token.raw, token.startCol),
    };
}, _Parser_orphanEndTagToBogusMark = function _Parser_orphanEndTagToBogusMark(nodeList) {
    const newNodeList = [];
    for (let node of nodeList) {
        if (node.type === 'endtag') {
            const endTagUUID = node.uuid;
            const openTag = newNodeList.findLast((n) => n.type === 'starttag' && !n.isGhost ? n.pairNode?.uuid === endTagUUID : false);
            if (!openTag) {
                node = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_convertIntoInvalidNode).call(this, node);
            }
        }
        newNodeList.push(node);
    }
    return newNodeList;
}, _Parser_pairing = function _Parser_pairing(startTag, endTag, appendChild = true) {
    Object.assign(startTag, { pairNode: endTag });
    Object.assign(endTag, { pairNode: startTag });
    if (!appendChild) {
        return;
    }
    this.appendChild(startTag.parentNode, endTag);
}, _Parser_parseEndTag = function _Parser_parseEndTag(token, namelessFragment) {
    const parsed = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseTag).call(this, token, true, false, namelessFragment);
    if (!parsed.token || parsed.token.type !== 'endtag') {
        throw new ParserError("Expected end tag but it's not end tag", token);
    }
    return parsed.token;
}, _Parser_parseStartTag = function _Parser_parseStartTag(token, overwriteProps, namelessFragment) {
    const parsed = __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseTag).call(this, token, true, false, namelessFragment);
    if (!parsed.token || parsed.token.type !== 'starttag') {
        throw new ParserError("Expected start tag but it's not start tag", token);
    }
    const startTag = {
        ...parsed.token,
        ...overwriteProps,
    };
    this.appendChild(token.parentNode, startTag);
    return startTag;
}, _Parser_parseTag = function _Parser_parseTag(token, praseAttr, failSafe, namelessFragment) {
    const raw = token.raw;
    const depth = token.depth;
    const initialOffset = token.startOffset;
    const initialLine = token.startLine;
    const initialCol = token.startCol;
    let offset = initialOffset;
    let line = initialLine;
    let col = initialCol;
    let tagStartOffset = offset;
    let tagStartLine = line;
    let tagStartCol = col;
    let state = TagState.BeforeOpenTag;
    let beforeOpenTagChars = '';
    let tagName = '';
    let afterAttrsSpaceChars = '';
    let selfClosingSolidusChar = '';
    let isOpenTag = true;
    const attrs = [];
    const chars = [...raw];
    while (chars.length > 0) {
        if (state === TagState.AfterOpenTag) {
            break;
        }
        const char = chars.shift();
        stateSwitch: switch (state) {
            case TagState.BeforeOpenTag: {
                if (char === '<') {
                    const beforeOpenTag = this.createToken(beforeOpenTagChars, offset, line, col);
                    line = beforeOpenTag.endLine;
                    col = beforeOpenTag.endCol;
                    offset = beforeOpenTag.endOffset;
                    tagStartOffset = offset;
                    tagStartLine = line;
                    tagStartCol = col;
                    // Add `<` length
                    col += 1;
                    offset += 1;
                    state = TagState.FirstCharOfTagName;
                    break;
                }
                beforeOpenTagChars += char;
                break;
            }
            case TagState.FirstCharOfTagName: {
                if (/[a-z]/i.test(char)) {
                    tagName += char;
                    state = TagState.TagName;
                    break;
                }
                if (char === '/') {
                    isOpenTag = false;
                    break;
                }
                if (namelessFragment && char === '>') {
                    state = TagState.AfterOpenTag;
                    break;
                }
                chars.unshift(char);
                state = TagState.AfterOpenTag;
                break;
            }
            case TagState.TagName: {
                if (__classPrivateFieldGet(this, _Parser_spaceChars, "f").includes(char)) {
                    chars.unshift(char);
                    if (!isOpenTag) {
                        // Add `/` of `</`(close tag) length
                        offset += 1;
                        col += 1;
                    }
                    offset += tagName.length;
                    col += tagName.length;
                    state = TagState.Attrs;
                    break;
                }
                if (char === '/') {
                    chars.unshift(char);
                    state = TagState.AfterAttrs;
                    break;
                }
                if (char === '>') {
                    state = TagState.AfterOpenTag;
                    break;
                }
                tagName += char;
                break;
            }
            case TagState.Attrs: {
                if (!praseAttr) {
                    state = TagState.AfterAttrs;
                    break stateSwitch;
                }
                let leftover = char + chars.join('');
                while (leftover.trim()) {
                    if (leftover.trim().startsWith('/') || leftover.trim().startsWith('>')) {
                        chars.length = 0;
                        chars.push(...leftover);
                        state = TagState.AfterAttrs;
                        break stateSwitch;
                    }
                    const attr = this.visitAttr({
                        raw: leftover,
                        startOffset: offset,
                        startLine: line,
                        startCol: col,
                    });
                    line = attr.endLine;
                    col = attr.endCol;
                    offset = attr.endOffset;
                    if (leftover === attr.__rightText) {
                        throw new SyntaxError(`Invalid attribute syntax: ${leftover}`);
                    }
                    leftover = attr.__rightText == null ? '' : `${attr.__rightText}`;
                    delete attr.__rightText;
                    attrs.push(attr);
                }
                break;
            }
            case TagState.AfterAttrs: {
                if (char === '>') {
                    state = TagState.AfterOpenTag;
                    break;
                }
                if (__classPrivateFieldGet(this, _Parser_spaceChars, "f").includes(char)) {
                    afterAttrsSpaceChars += char;
                    break;
                }
                if (char === '/') {
                    selfClosingSolidusChar = char;
                    break;
                }
                if (!praseAttr) {
                    break;
                }
                throw new SyntaxError(`Invalid tag syntax: "${raw}"`);
            }
        }
    }
    const leftover = chars.join('');
    if (!failSafe && !leftover && state === TagState.TagName) {
        throw new SyntaxError(`Invalid tag syntax: "${raw}"`);
    }
    if (!failSafe && !namelessFragment && tagName === '') {
        throw new SyntaxError(`No tag name: "${raw}"`);
    }
    const endSpace = this.createToken(afterAttrsSpaceChars, offset, line, col);
    line = endSpace.endLine;
    col = endSpace.endCol;
    offset = endSpace.endOffset;
    const selfClosingSolidus = this.createToken(selfClosingSolidusChar, offset, line, col);
    line = selfClosingSolidus.endLine;
    col = selfClosingSolidus.endCol;
    offset = selfClosingSolidus.endOffset;
    const rawCodeFragment = raw.slice(beforeOpenTagChars.length, raw.length - leftover.length);
    if (!rawCodeFragment) {
        return {
            __left: beforeOpenTagChars,
            __right: leftover,
        };
    }
    const tagToken = this.createToken(rawCodeFragment, tagStartOffset, tagStartLine, tagStartCol);
    const isFragment = tagName === '';
    const commons = {
        depth,
        nodeName: isFragment ? '#jsx-fragment' : tagName,
        parentNode: null,
    };
    const tag = isOpenTag
        ? {
            ...tagToken,
            ...commons,
            type: 'starttag',
            elementType: this.detectElementType(tagName),
            namespace: '',
            attributes: attrs,
            childNodes: [],
            pairNode: null,
            tagOpenChar: '<',
            tagCloseChar: selfClosingSolidusChar + '>',
            selfClosingSolidus,
            isGhost: false,
            isFragment,
        }
        : {
            ...tagToken,
            ...commons,
            type: 'endtag',
            pairNode: {},
            tagOpenChar: '</',
            tagCloseChar: '>',
        };
    return {
        token: tag,
        __left: beforeOpenTagChars,
        __right: leftover,
    };
}, _Parser_removeChild = function _Parser_removeChild(parentNode, ...childNodes) {
    if (!parentNode || childNodes.length === 0) {
        return;
    }
    const newChildNodes = parentNode.childNodes.filter(n => !childNodes.includes(n));
    Object.assign(parentNode, { childNodes: newChildNodes });
}, _Parser_removeDeprecatedNode = function _Parser_removeDeprecatedNode(nodeOrders) {
    /**
     * sorting
     */
    const sorted = Array.prototype.toSorted == null
        ? // TODO: Use sort instead of toSorted until we end support for Node 18
            [...nodeOrders].sort(sortNodes)
        : nodeOrders.toSorted(sortNodes);
    /**
     * remove duplicated node
     */
    const stack = {};
    const removeIndexes = [];
    for (const [i, node] of sorted.entries()) {
        const id = `${node.startOffset}::${node.nodeName}`;
        if (stack[id] != null) {
            removeIndexes.push(i);
        }
        stack[id] = i;
    }
    let r = sorted.length;
    while (r-- > 0) {
        if (removeIndexes.includes(r)) {
            sorted.splice(r, 1);
        }
    }
    return sorted;
}, _Parser_removeOffsetSpaces = function _Parser_removeOffsetSpaces(nodeList, options) {
    const offsetOffset = options?.offsetOffset ?? 0;
    const offsetLine = options?.offsetLine ?? 1;
    const offsetColumn = options?.offsetColumn ?? 1;
    if (offsetOffset === 0) {
        return nodeList;
    }
    const firstNode = nodeList.at(0);
    if (!firstNode || firstNode.type !== 'text') {
        return nodeList;
    }
    const raw = firstNode.raw.slice(offsetOffset);
    if (!raw) {
        if (Array.prototype.toSpliced == null) {
            const newNodeList = [...nodeList];
            // TODO: Use splice instead of toSpliced until we end support for Node 18
            newNodeList.splice(0, 1);
            return newNodeList;
        }
        return nodeList.toSpliced(0, 1);
    }
    this.updateRaw(firstNode, raw);
    this.updateLocation(firstNode, {
        startOffset: offsetOffset,
        startLine: offsetLine,
        startCol: offsetColumn,
    });
    return nodeList;
}, _Parser_reset = function _Parser_reset() {
    // Reset state
    this.state = structuredClone(__classPrivateFieldGet(this, _Parser_defaultState, "f"));
    __classPrivateFieldSet(this, _Parser_defaultDepth, 0, "f");
}, _Parser_setRawCode = function _Parser_setRawCode(rawCode, originalRawCode) {
    __classPrivateFieldSet(this, _Parser_rawCode, rawCode, "f");
    __classPrivateFieldSet(this, _Parser_originalRawCode, originalRawCode ?? __classPrivateFieldGet(this, _Parser_originalRawCode, "f"), "f");
}, _Parser_siblingsCorrection = function _Parser_siblingsCorrection(nodes) {
    const stack = new Set();
    const newNodes = [];
    const oldNodes = Array.prototype.toSorted == null
        ? // TODO: Use sort instead of toSorted until we end support for Node 18
            [...nodes].sort(sortNodes)
        : nodes.toSorted(sortNodes);
    const nameToLastOpenTag = {};
    for (const node of oldNodes) {
        const id = `${node.startOffset}::${node.nodeName}`;
        if (stack.has(id)) {
            continue;
        }
        stack.add(id);
        if (node.type === 'endtag') {
            const openTag = nameToLastOpenTag[node.nodeName];
            if (openTag && !openTag.pairNode) {
                __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_pairing).call(this, openTag, node, false);
                newNodes.push(node);
                continue;
            }
        }
        else if (node.type === 'starttag') {
            nameToLastOpenTag[node.nodeName] = node;
        }
        newNodes.push(node);
    }
    return newNodes;
}, _Parser_trimText = function _Parser_trimText(nodeList) {
    const newNodeList = [];
    let prevNode = null;
    for (const node of nodeList) {
        if (prevNode?.type === 'text' &&
            // Empty node
            node.startOffset !== node.endOffset) {
            const prevNodeEndOffset = prevNode.endOffset;
            const nodeStartOffset = node.startOffset;
            if (prevNodeEndOffset > nodeStartOffset) {
                const prevNodeRaw = prevNode.raw;
                const prevNodeTrimmedRaw = prevNodeRaw.slice(0, nodeStartOffset - prevNode.startOffset);
                this.updateRaw(prevNode, prevNodeTrimmedRaw);
            }
        }
        newNodeList.push(node);
        prevNode = node;
    }
    return newNodeList;
};
