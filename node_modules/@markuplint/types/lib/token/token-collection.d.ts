import type { TokenValue } from './types.js';
import type { Expect, Result, List, UnmatchedResult } from '../types.js';
import { Token } from './token.js';
type TokenCollectionOptions = Partial<Omit<List, 'token'> & {
    specificSeparator: string | string[];
}>;
export type TokenEachCheck = (head: Readonly<Token> | null, tail: TokenCollection) => Result | void;
export declare class TokenCollection extends Array<Token> {
    static fromPatterns(value: Readonly<Token> | string, patterns: readonly Readonly<RegExp>[], typeOptions?: Omit<TokenCollectionOptions, 'specificSeparator'> & {
        repeat?: boolean;
    }): TokenCollection;
    static get [Symbol.species](): ArrayConstructor;
    readonly allowEmpty: NonNullable<List['allowEmpty']>;
    readonly caseInsensitive: NonNullable<List['caseInsensitive']>;
    readonly disallowToSurroundBySpaces: NonNullable<List['disallowToSurroundBySpaces']>;
    readonly number: List['number'];
    readonly ordered: NonNullable<List['ordered']>;
    readonly separator: NonNullable<List['separator']>;
    readonly unique: NonNullable<List['unique']>;
    constructor(value?: string, typeOptions?: TokenCollectionOptions);
    constructor(value?: number);
    get value(): string;
    check(options?: {
        expects?: Expect[];
        ref?: string;
        cache?: boolean;
    }): import("../types.js").MatchedResult | UnmatchedResult;
    chunk(split: number): TokenCollection[];
    compareTokens(callback: (prev: Readonly<Token>, current: Readonly<Token>) => Readonly<Token> | null | void): Readonly<Token> | null | undefined;
    divide(position: number): readonly [TokenCollection, TokenCollection];
    eachCheck(...callbacks: readonly TokenEachCheck[]): Result;
    filter(callback: Parameters<Array<Token>['filter']>[0]): TokenCollection;
    getConsecutiveToken(tokenType: number): Readonly<Token> | null;
    getDuplicated(): Token | null;
    getIdentTokens(): TokenCollection;
    /**
     *
     * @param value The token value or the token type or its list
     */
    has(value: TokenValue): boolean;
    headAndTail(): {
        head: Token | null;
        tail: TokenCollection;
    };
    /**
     *
     * @param value The token value or the token type or its list
     */
    search(value: TokenValue): Token | null;
    takeTurns(tokenNumbers: ReadonlyArray<number>, lastTokenNumber?: number): {
        unexpectedLastToken: boolean;
        expectedTokenNumber: number | undefined;
        token: Token;
    } | null;
    toJSON(): {
        type: number;
        value: string;
        offset: number;
    }[];
    private static _new;
}
export {};
